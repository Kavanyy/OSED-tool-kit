#!/usr/bin/python3
import sys
import readline
import re
from keystone import *
from capstone import *
from colorama import init, Fore, Style, Back

init(autoreset=True)

class PolymorphicEngine:
    def __init__(self):
        pass

    def _to_int(self, val_str):
        try:
            return int(val_str, 16) if '0x' in val_str.lower() else int(val_str)
        except:
            return None

    def get_suggestions(self, mnemonic, operands):
        sugs = []
        op_list = [op.strip() for op in operands.split(',')]
        
        if mnemonic == 'mov' and len(op_list) == 2:
            dest, src = op_list[0], op_list[1]
            val = self._to_int(src)

            if val == 0:
                sugs.extend([
                    f"xor {dest}, {dest}",
                    f"sub {dest}, {dest}",
                    f"and {dest}, 0"
                ])
                if dest.lower() == 'edx': sugs.append("cdq ; (If EAX+)")
            
            elif val is not None:
                if 0 < val <= 127: 
                    sugs.append(f"push {val}; pop {dest}")
                    # xor reg, reg -> mov reg8, val
                    reg8 = dest.replace('e','').replace('x','l')
                    sugs.append(f"xor {dest}, {dest}; mov {reg8}, {val}")
                
                # 2's Complement (Negation)
                neg_val = (0xFFFFFFFF ^ val) + 1
                neg_hex = f"0x{neg_val & 0xFFFFFFFF:08x}"
                sugs.append(f"mov {dest}, {neg_hex}; neg {dest}")

                val_minus = val - 1
                sugs.append(f"mov {dest}, {hex(val_minus)}; inc {dest}")
                
                sugs.append(f"push {hex(val)}; pop {dest}")            # stack Push/Pop

        elif mnemonic == 'push' and len(op_list) == 1:
            src = op_list[0]
            val = self._to_int(src)
            
            if val == 0:
                sugs.append("xor eax, eax; push eax") 
                sugs.append("push -1; inc dword ptr [esp]")
            elif val is not None and val < 128:
                 sugs.append(f"mov eax, {val}; push eax")

        elif mnemonic in ['add', 'sub'] and len(op_list) == 2:
            dest, src = op_list[0], op_list[1]
            val = self._to_int(src)
            target = "sub" if mnemonic == "add" else "add"
            if val is not None:
                neg_val = (0xFFFFFFFF ^ val) + 1
                sugs.append(f"{target} {dest}, 0x{neg_val & 0xFFFFFFFF:x}")

        return sugs

class KasmShell:
    def __init__(self, bad_chars):
        self.bad_chars = bad_chars if bad_chars else [0x00]
        self.ks = Ks(KS_ARCH_X86, KS_MODE_32)
        self.cs = Cs(CS_ARCH_X86, CS_MODE_32)
        self.poly = PolymorphicEngine()
        self.history_file = ".kasm_history"
        self.last_bytecode = None 
        
        try:
            readline.read_history_file(self.history_file)
        except FileNotFoundError:
            pass

    def check_bad(self, data):
        return [b for b in data if b in self.bad_chars]

    def print_banner(self):
        bc_str = ', '.join([f'\\x{b:02x}' for b in self.bad_chars])
        b = f"""
{Fore.RED}██╗  ██╗ █████╗ ███████╗███╗   ███╗{Fore.WHITE}   SHELLCODE DEV KERNEL v6.1
{Fore.RED}██║ ██╔╝██╔══██╗██╔════╝████╗ ████║{Fore.WHITE}   [ Keystone Engine x86 ]
{Fore.RED}█████╔╝ ███████║███████╗██╔████╔██║{Fore.WHITE}   [ Null-Free Generator ]
{Fore.RED}██╔═██╗ ██╔══██║╚════██║██║╚██╔╝██║{Fore.WHITE}   [ OSED Helper Tool ]
{Fore.RED}██║  ██╗██║  ██║███████║██║ ╚═╝ ██║{Fore.WHITE}
{Fore.RED}╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝{Fore.WHITE}   @Kavany 
{Style.DIM}------------------------------------------------------------------
{Fore.YELLOW}[!] Active Bad Chars: {Fore.RED}{bc_str}
{Fore.WHITE}Type {Fore.GREEN}.help{Fore.WHITE} for commands.
"""
        print(b)

    def show_help(self):
        h = f"""
{Fore.YELLOW}=== AVAILABLE COMMANDS ==={Style.RESET_ALL}

{Fore.GREEN}.help{Style.RESET_ALL}              Show this message.
{Fore.GREEN}.bc{Style.RESET_ALL}                Show current bad chars.
{Fore.GREEN}.bc = 00 0a ...{Style.RESET_ALL}    REPLACE the bad char list.
{Fore.GREEN}.bc + ff ...{Style.RESET_ALL}       ADD bytes to the current list.
{Fore.GREEN}.string "text"{Style.RESET_ALL}    Generate PUSH instructions for stack strings (Null-Free).
{Fore.GREEN}.save file.bin{Style.RESET_ALL}     Save the last generated bytecode to a file.
{Fore.GREEN}.clear{Style.RESET_ALL}             Clear screen.
{Fore.GREEN}exit / q{Style.RESET_ALL}           Quit.

{Fore.YELLOW}=== USAGE ==={Style.RESET_ALL}
* Standard ASM:             {Fore.CYAN}mov eax, 1{Style.RESET_ALL}
* Multiple instructions:    {Fore.CYAN}xor eax, eax; push eax{Style.RESET_ALL}
* Paste HEX to disasm:      {Fore.CYAN}eb 05 90 90{Style.RESET_ALL}
"""
        print(h)

    def handle_badchars_cmd(self, cmd):
        parts = cmd.split()
        
        if len(parts) == 1: # .bc
            bc_str = ', '.join([f'\\x{b:02x}' for b in self.bad_chars])
            print(f"{Fore.YELLOW}[*] Current Bad Chars: {Fore.RED}{bc_str}{Style.RESET_ALL}")
            return

        op = parts[1] # = or +
        new_values = []
        
        try:
            # Parse remaining args
            raw_vals = parts[2:]
            for v in raw_vals:
                v = v.replace('0x', '').replace(',', '')
                new_values.append(int(v, 16))
            
            if op == '=':
                self.bad_chars = new_values
                print(f"{Fore.GREEN}[+] Bad char list REPLACED.{Style.RESET_ALL}")
            elif op == '+':
                # Add without duplicates
                for val in new_values:
                    if val not in self.bad_chars:
                        self.bad_chars.append(val)
                self.bad_chars.sort()
                print(f"{Fore.GREEN}[+] Bad chars ADDED.{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}[!] Unknown operator. Use '=' or '+'{Style.RESET_ALL}")

            # Show result
            bc_str = ', '.join([f'\\x{b:02x}' for b in self.bad_chars])
            print(f"    New list: {Fore.RED}{bc_str}{Style.RESET_ALL}")

        except ValueError:
            print(f"{Fore.RED}[!] Error: Invalid HEX format.{Style.RESET_ALL}")


    def generate_stack_string(self, text):
        print(f"\n{Fore.YELLOW}[*] Generating Null-Free Stack String for: '{text}'{Style.RESET_ALL}")
        data = text.encode('utf-8')
        instructions = ["xor ebx, ebx; push ebx ; // Null Terminator"]
        chunks = [data[i:i+4] for i in range(0, len(data), 4)]
        chunks.reverse()

        for chunk in chunks:
            chunk_len = len(chunk)
            val = 0
            for i, b in enumerate(chunk):
                val |= b << (i * 8)
            
            if chunk_len == 4:
                val_hex = f"0x{val:08x}"
                instructions.append(f"push {val_hex} ; // {chunk.decode('utf-8', 'ignore')}")
            else:
                padding_needed = 4 - chunk_len
                shift_bits = padding_needed * 8
                garbage = 0x41 
                val_with_garbage = val
                for i in range(chunk_len, 4):
                     val_with_garbage |= (garbage << (i*8))
                
                val_garbage_hex = f"0x{val_with_garbage:08x}"
                instructions.append(f"; // Partial block '{chunk.decode('utf-8','ignore')}'")
                instructions.append(f"mov eax, {val_garbage_hex}")
                instructions.append(f"shr eax, {shift_bits} ; // Clean garbage")
                instructions.append("push eax")

        for inst in instructions:
            self.assemble_line(inst)

    def assemble_line(self, line):
        try:
            match = re.match(r'^([a-z]+)(?:\s+(.*))?$', line.lower().strip())
            mnemonic = match.group(1) if match else line
            operands = match.group(2) if match and match.group(2) else ""

            encoding, _ = self.ks.asm(line)
            self.last_bytecode = encoding 
            
            hex_str = ""
            has_bad = False
            for b in encoding:
                if b in self.bad_chars:
                    hex_str += f"{Back.RED}{Fore.WHITE}{b:02x}{Style.RESET_ALL}"
                    has_bad = True
                else:
                    hex_str += f"{Fore.GREEN}{b:02x}{Style.RESET_ALL}"
            
            print(f"{Fore.CYAN}ASM: {Style.RESET_ALL}{line:<35} {Fore.LIGHTBLACK_EX}| {hex_str} {Fore.WHITE}({len(encoding)}){Style.RESET_ALL}")

            if has_bad:
                print(f"{Fore.RED} └── [!] BAD CHAR DETECTED! Alternatives:{Style.RESET_ALL}")
                sugs = self.poly.get_suggestions(mnemonic, operands)
                valid = 0
                for sug in sugs:
                    is_clean = True
                    sug_bytes = b""
                    try:
                        for part in sug.split(';'):
                            enc, _ = self.ks.asm(part.strip())
                            if self.check_bad(enc): 
                                is_clean = False
                                break
                            sug_bytes += bytes(enc)
                        if is_clean:
                            raw_hex = "".join(f"{b:02x}" for b in sug_bytes)
                            print(f"     {Fore.GREEN}✓ {sug:<35} {Fore.LIGHTBLACK_EX}| {raw_hex}{Style.RESET_ALL}")
                            valid += 1
                    except: continue
                if valid == 0: print(f"     {Fore.LIGHTBLACK_EX}(No automatic alternatives){Style.RESET_ALL}")

        except KsError as e:
            print(f"{Fore.RED}[-] Error: {e}{Style.RESET_ALL}")

    def disassemble(self, hex_str):
        try:
            clean_hex = hex_str.lower().replace("\\x", "").replace(" ", "").replace("0x", "")
            data = bytes.fromhex(clean_hex)
            print(f"{Fore.YELLOW}[*] Disassembly:{Style.RESET_ALL}")
            for i in self.cs.disasm(data, 0x1000):
                bad_in_ins = self.check_bad(i.bytes)
                mark = f"{Back.RED} BAD {Style.RESET_ALL}" if bad_in_ins else ""
                print(f"  0x{i.address:x}: {Fore.CYAN}{i.mnemonic:<6} {i.op_str:<25}{Style.RESET_ALL} {mark}")
        except Exception as e:
            print(f"{Fore.RED}[-] Hex Error: {e}{Style.RESET_ALL}")

    def run(self):
        self.print_banner()
        while True:
            try:
                cmd = input(f"{Fore.BLUE}kasm > {Style.RESET_ALL}").strip()
                if not cmd: continue
                readline.write_history_file(self.history_file)

                if cmd.lower() in ['exit', 'q', 'quit']: break
                
                if cmd.lower() == '.help':
                    self.show_help()
                    continue

                if cmd.lower().startswith('.bc'):
                    self.handle_badchars_cmd(cmd)
                    continue

                if cmd.lower() == '.clear': 
                    print("\033[H\033[J", end="") 
                    self.print_banner()
                    continue
                
                if cmd.startswith(".save"):
                    parts = cmd.split()
                    fname = parts[1] if len(parts) > 1 else "payload.bin"
                    if self.last_bytecode:
                        with open(fname, "wb") as f: f.write(bytes(self.last_bytecode))
                        print(f"{Fore.GREEN}[+] Bytecode saved to: {fname}{Style.RESET_ALL}")
                    continue

                if cmd.startswith(".string"):
                    match = re.search(r'\.string\s+"([^"]+)"', cmd)
                    if match: self.generate_stack_string(match.group(1))
                    else: print(f"{Fore.RED}[!] Usage: .string \"text\"{Style.RESET_ALL}")
                    continue

                if all(c in "0123456789abcdef\\x " for c in cmd.lower()) and len(cmd) > 3 and "mov" not in cmd.lower():
                    self.disassemble(cmd)
                else:
                    for sub in cmd.split(';'):
                        if sub.strip(): self.assemble_line(sub.strip())

            except (KeyboardInterrupt, EOFError):
                break

if __name__ == "__main__":
    args = sys.argv[1:]
    bad_bytes = [int(x, 16) for x in args] if args else [0x00]
    shell = KasmShell(bad_bytes)
    shell.run()